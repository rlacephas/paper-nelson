
Function inlining, or simply inlining, is a classic code transformation that can significantly increase the performance of many programs.  A compiler pass that decides which calls to inline, and in which order, is referred to as an inliner.  The basic idea of inlining is straightforward: rather than making a function call, replace the call in the originating function with a copy of the body of the to-be-called function.  Nonetheless, many inliner designs are possible; \cite{BerubePhD} describes the existing inliner in \llvm, and also the alternative approach used by a new feedback-directed inliner (\FDI) that uses \CP. All inlining discussed in this paper is implemented in the open-source \llvm\ compiler~\cite{LattnerAdveCGO04}.

Some terminology is required to identify the various functions and calls involved in the inlining process.  The function making a call is referred to as the {\it caller}, while the called function is the {\it callee}.  The representation of a call in a compiler's {\it internal representation} (IR) is a {\it call site}; in \llvm, a call site is an instruction that indicates both the caller and the callee.  Thus, inlining replaces a call site by a copy of that call site's callee. When a call is inlined, the callee may contain call sites, which are copied into the caller to produce new call sites.  The call site where inlining occurs is called the {\it source} call site.  A call site in the callee that is copied during inlining is called an {\it original} call site, and the new copy of the original call site inside the caller is called the {\it target} call site.

\subsection{Barriers to Inlining}

Not every call site can be inlined.  Indirect calls use a pointer variable to identify the location of the called code, and arise from function pointers and dynamically-polymorphic call dispatching.  These calls cannot be inlined, because the callee is unknown at compiler time.  External calls into code not currently available in the compiler, such as calls into different modules or to statically-linked library functions cannot be inlined before link-time because the source representation of the callee is not available in the compiler. Calls to dynamically-linked libraries can never be inlined by definition. Moreover, if a callee uses a \name{setjump} instruction, it cannot be inlined. A \name{setjump} can redirect program control flow {\it anywhere}, including the middle of different function, without using the call/return mechanisms.  Inlining the \name{setjump} could cause any manual stack management at the target of the jump to be incorrect; the inlined version would not be functionally equivalent to the original.

\subsection{Benefits of Inlining}

Inlining a call has a small direct benefit.  Removing the call reduces the number of executed instructions.  The {\tt call} instruction in the caller is unnecessary, as is the {\tt return} instruction in the callee.  Furthermore, any parameters passed to the callee and any values returned no longer need to be pushed onto the stack\footnote{Some calling conventions allow values to pass between  the caller and callee in registers.}.

However, the greatest potential benefit of inlining comes from additional code simplification it may enable by bringing the callee's code into the caller's scope \cite{BerubePhD}. Many code analysis algorithms work within the scope of a single function; inter-procedural analysis is usually fundamentally more difficult, and always more computationally expensive than intra-procedural analysis, because of the increased scope.  A function call inhibits the precision of analyses and is a barrier to code motion because the caller sees the callee as a ``black box'' with unknown effect.

\subsection{Costs of Inlining}

Inlining non-profitable call sites can indirectly produce negative effects.  The increased scope provided for analysis by inlining also increases the costs of these analyses.  Most algorithms used by compilers have super-linear time complexity.  Extremely large procedures may take excessively long to analyze; some compilers will abort an analysis that takes too long.  Furthermore, a program must be loaded into memory from disk before it can be executed.  A larger executable file size increases a program's start-up time.  Finally, developers eschew unnecessarily large program binaries because of the costs associated with the storage and transmission of large files for both the developer and their clients. Therefore, inlining that does not improve performance should be avoided.

\subsection{Inlining-Invariant Program Characteristics}

While inlining a call causes a large change in the caller's code, it has a minimal direct impact of the use of memory system resources at run time \cite{BerubePhD}.  Ignoring the subsequent simplifications the inlining enables, inlining proper has no appreciable impact on register use, or data or instruction cache efficiency.  Regardless of inlining, the same dynamic sequence of instructions must process the same data in the same order to produce the same deterministic program result.

Inlining should have negligible impact register spills.  The additional variables introduced into the caller by inlining place additional demands on the register allocator, and may increase the number of register spills introduced into the caller.  However, without inlining, the calling convention requires the caller to save any live registers before making a call, or for the callee to save any registers before it uses them; in both cases, these registers must be restored before resuming execution in the caller. Thus, inlining merely shifts the responsibility for register management from the calling convention to the register allocator.

Similarly, inlining does not change the data memory accesses of a program.  Whether in the caller or the callee, the same loads and stores, in the same order, are required for correct computation. Subsequent transformations may reorder independent memory accesses to better hide cache latency, or eliminate unnecessary accesses altogether, but this is not a direct consequence of inlining.  Thus, data cache accesses do not change with inlining, and nor does the cache miss rate.  
